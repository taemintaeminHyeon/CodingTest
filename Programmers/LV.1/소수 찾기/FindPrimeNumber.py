'''
solution
간단하게 각 수 마다 나누기를 통해 소수를 찾으려고 하였다.
문제에서 2이상의 수를 제시하였기 때문에 범위를 2에서 부터 n까지를 설정하여
각 수에 대한 나누기를 진행 만약 나눠지면 소수가 아니므로 다음 반복으로 넘어가고 마지막까지 나눠지지 않으면 소수로 한다
-> 이렇게 하니 실행시간이 너무 오래걸려 시간초과가 발생함

solution2
최적화를 할 방법이 생각나지 않아 검색해봄
'에라토스테네스의 체' 방법을 사용함
소수는 말그래도 자기자신과 1로만 나눠지는 수 이다.
그렇기 때문에 2를 제외하고 2의 배수, 3을 제외하고 3의배수 ... 이렇게 제외하고 남은 수의 배수를 제외하면
소수만 남게 된다는 것이다.
그렇기 때문에 배열로 2 ~ n 까지 선언해 주고
2를 제외한 다음부터 2의 배수를 제거 다음
3을 제외한 다음부터 3의 배수를 제거 (2와 3은 소수)
그리고 다음 존재하는 수의 배수를 제거한다.
이렇게 하면 소수만 남는다!

'''

def solution(n):
    answer = 1

    for i in range(2, n+1):

        for j in range(2, i):

            if i % j == 0:
                break

            if j == i-1:
                answer += 1

    return answer


def solution2(n):
    num = set(range(2, n + 1))

    for i in range(2, n + 1):
        if i in num:
            num -= set(range(2 * i, n + 1, i))

    return len(num)
